"""
Строитель — это порождающий паттерн проектирования, который позволяет создавать сложные объекты пошагово.
Строитель даёт возможность использовать один и тот же код строительства для получения разных представлений объектов.


Проблема
Представьте сложный объект, требующий кропотливой пошаговой инициализации множества полей и вложенных объектов. 
Код инициализации таких объектов обычно спрятан внутри монструозного конструктора с десятком параметров. Либо ещё хуже — распылён по всему клиентскому коду.

Например, давайте подумаем о том, как создать объект Дом. Чтобы построить стандартный дом, нужно поставить 4 стены, 
установить двери, вставить пару окон и положить крышу. Но что, если вы хотите дом побольше да посветлее, имеющий сад, бассейн и прочее добро?
Самое простое решение — расширить класс Дом, создав подклассы для всех комбинаций параметров дома. 
Проблема такого подхода — это громадное количество классов, которые вам придётся создать.
Каждый новый параметр, вроде цвета обоев или материала кровли, заставит вас создавать всё больше и больше классов для перечисления всех возможных вариантов.
Чтобы не плодить подклассы, вы можете подойти к решению с другой стороны. Вы можете создать гигантский конструктор Дома,
принимающий уйму параметров для контроля над создаваемым продуктом. Действительно, это избавит вас от подклассов, но приведёт к другой проблеме.
Телескопический конструктор
Конструктор со множеством параметров имеет свой недостаток: не все параметры нужны большую часть времени.

Большая часть этих параметров будет простаивать, а вызовы конструктора будут выглядеть монструозно из-за длинного списка параметров. 
К примеру, далеко не каждый дом имеет бассейн, поэтому параметры, связанные с бассейнами, будут простаивать бесполезно в 99% случаев.


Решение
Паттерн Строитель предлагает вынести конструирование объекта за пределы его собственного класса, поручив это дело отдельным объектам, называемым строителями.
Паттерн предлагает разбить процесс конструирования объекта на отдельные шаги (например, построитьСтены, 
вставитьДвери и другие). Чтобы создать объект, вам нужно поочерёдно вызывать методы строителя.
Причём не нужно запускать все шаги, а только те, что нужны для производства объекта определённой конфигурации.
 
Директор
Вы можете пойти дальше и выделить вызовы методов строителя в отдельный класс, называемый директором.
 В этом случае директор будет задавать порядок шагов строительства, а строитель — выполнять их.
 
 
 +
 Позволяет создавать продукты пошагово.
 Позволяет использовать один и тот же код для создания различных продуктов.
 Изолирует сложный код сборки продукта от его основной бизнес-логики.
 -
 Усложняет код программы из-за введения дополнительных классов.
 ConcreteBuilder и создаваемый им продукт жестко связаны между собой,  поэтому при внесеннии изменений в класс продукта скорее всего придется соотвествующим образом изменять и класс ConcreteBuilder.
"""
from abc import ABC, abstractmethod


class IBuilder(ABC):
    """
    Интерфейс Строителя объявляет создающие методы для различных частей объектов
    Продуктов.
    """
    PRODUCT_CLASS = None

    @abstractmethod
    def produce_part_a(self, obj):
        pass

    @abstractmethod
    def produce_part_b(self, obj):
        pass

    @abstractmethod
    def produce_part_c(self, obj):
        pass


class BuilderA(IBuilder):
    PRODUCT_CLASS = list

    def produce_part_a(self, obj):
        print("BuilderA produce_part_a")

    def produce_part_b(self, obj):
        print("BuilderA produce_part_b")

    def produce_part_c(self, obj):
        print("BuilderA produce_part_c")


class BuilderB(IBuilder):
    PRODUCT_CLASS = dict

    def produce_part_a(self, obj):
        print("BuilderB produce_part_a")

    def produce_part_b(self, obj):
        print("BuilderB produce_part_b")

    def produce_part_c(self, obj):
        print("BuilderB produce_part_c")


class Director:

    def __init__(self):
        self.__builder = None

    def setBuilder(self, builder):
        self.__builder = builder

    def build(self):
        product = self.__builder.PRODUCT_CLASS()
        self.__builder.produce_part_a(product)
        self.__builder.produce_part_b(product)
        self.__builder.produce_part_c(product)
        return product


if __name__ == '__main__':
    d = Director()
    d.setBuilder(BuilderA())
    a = d.build()
    d.setBuilder(BuilderB())
    b = d.build()
